// Lil Terminal
#include "lil.h"
#include "dom.h"
#ifndef __COSMOPOLITAN__
#include <sys/wait.h>
#include <unistd.h>
#endif

#include "lib/bestline.h"
#include "lib/bestline.c"


// Function to write bytecode to an assembly file
void write_bytecode_to_assembly(lv* prog, const char* filename) {
    // Extract the source filename from the output filename (remove the 's' at the end)
    char source_filename[4096];
    strncpy(source_filename, filename, sizeof(source_filename) - 1);
    source_filename[sizeof(source_filename) - 1] = '\0';
    int len = strlen(source_filename);
    if (len > 0 && source_filename[len - 1] == 's') {
        source_filename[len - 1] = '\0';
    }
    FILE* file = fopen(filename, "w");
    if (!file) {
        fprintf(stderr, "Error: Could not open file %s for writing: %s\n", filename, strerror(errno));
        return;
    }

    // Opcodes names for comments
    const char* opcode_names[] = {
        "JUMP", "JUMPF", "LIT", "DUP", "DROP", "SWAP", "OVER", "BUND", 
        "OP1", "OP2", "OP3", "GET", "SET", "LOC", "AMEND", "TAIL", 
        "CALL", "BIND", "ITER", "EACH", "NEXT", "COL", "IPRE", "IPOST", "FIDX", "FMAP", "LINE"
    };

    // Generate symbolic labels for jump targets
    int* jump_targets = calloc(blk_here(prog), sizeof(int));
    int num_targets = 0;

    // First pass: identify all jump targets
    int pc = 0;
    while (pc < blk_here(prog)) {
        int op = blk_getb(prog, pc);
        if (op == JUMP || op == JUMPF || op == EACH || op == NEXT || op == FIDX) {
            int target = blk_gets(prog, pc + 1);
            int found = 0;
            for (int i = 0; i < num_targets; i++) {
                if (jump_targets[i] == target) {
                    found = 1;
                    break;
                }
            }
            if (!found) {
                jump_targets[num_targets++] = target;
            }
        }
        pc += oplens[op];
    }

    // Write header with $ORG meta instructions
    fprintf(file, "// Lil Assembly File\n");
    fprintf(file, "// Generated by lilc\n\n");
    
    // Write manifest with jump targets
    fprintf(file, "// Manifest of symbolic names to bytecode offsets\n");
    for (int i = 0; i < num_targets; i++) {
        fprintf(file, "$ORG L%d %d\n", i, jump_targets[i]);
    }
    fprintf(file, "\n");

    // Second pass: write the bytecode with comments
    pc = 0;
    while (pc < blk_here(prog)) {
        // Check if this is a jump target, and if so, add a label
        for (int i = 0; i < num_targets; i++) {
            if (jump_targets[i] == pc) {
                fprintf(file, "L%d:\n", i);
                break;
            }
        }

        int op = blk_getb(prog, pc);
        
		if (op == LINE) {
			int line_num = blk_gets(prog, pc + 1);
            fprintf(file, "; #%d\n", line_num + 1);
			pc += oplens[op];
			continue;
		}
	
        // Write the opcode
        fprintf(file, "    %s", opcode_names[op]);
        
        // Write operands based on opcode
        if (op == JUMP || op == JUMPF || op == EACH || op == NEXT || op == FIDX) {
            int target = blk_gets(prog, pc + 1);
            // Find the symbolic label for this target
            for (int i = 0; i < num_targets; i++) {
                if (jump_targets[i] == target) {
                    fprintf(file, " L%d", i);
                    break;
                }
            }
        } else if (op == LIT || op == GET || op == SET || op == LOC || op == AMEND) {
            int imm = blk_gets(prog, pc + 1);
            lv* val = blk_getimm(prog, imm);
            
            // Format the value based on its type
            if (lin(val)) {
                fprintf(file, " %g", val->nv);
            } else if (lis(val)) {
                fprintf(file, " \"%s\"", val->sv);
            } else if (lion(val)) {
                // Handle function literals
                fprintf(file, " \"function:%s\"", val->sv);
                
                // Add function body with curly braces
                fprintf(file, " {\n");
                
                // Write the function arguments as a comment
                fprintf(file, "      // Arguments: ");
                for (int i = 0; i < val->c; i++) {
                    fprintf(file, "%s ", val->lv[i]->sv);
                }
                fprintf(file, "\n");
                
                // Write the function body
                if (val->b && liblk(val->b)) {
                    int func_pc = 0;
                    while (func_pc < blk_here(val->b)) {
                        int func_op = blk_getb(val->b, func_pc);
                        fprintf(file, "      %s", opcode_names[func_op]);
                        
                        if (func_op == JUMP || func_op == JUMPF || func_op == EACH || func_op == NEXT || func_op == FIDX) {
                            int func_target = blk_gets(val->b, func_pc + 1);
                            fprintf(file, " %d", func_target);
                        } else if (func_op == LIT || func_op == GET || func_op == SET || func_op == LOC || func_op == AMEND) {
                            int func_imm = blk_gets(val->b, func_pc + 1);
                            lv* func_val = blk_getimm(val->b, func_imm);
                            
                            if (lin(func_val)) {
                                fprintf(file, " %g", func_val->nv);
                            } else if (lis(func_val)) {
                                fprintf(file, " \"%s\"", func_val->sv);
                            } else {
                                fprintf(file, " %d", func_imm);
                            }
                        } else if (func_op == BUND) {
                            fprintf(file, " %d", blk_gets(val->b, func_pc + 1));
                        }
                        
                        fprintf(file, "\n");
                        func_pc += oplens[func_op];
                    }
                } else {
                    fprintf(file, "      // (Function body not available)\n");
                }
                
                // Close the function body
                fprintf(file, "    }");
            } else {
                fprintf(file, " %d", imm);
            }
        } else if (op == OP1 || op == OP2 || op == OP3) {
            int imm = blk_gets(prog, pc + 1);
            
            // Get the primitive name
            primitive* prims = NULL;
            if (op == OP1) prims = monads;
            else if (op == OP2) prims = dyads;
            else if (op == OP3) prims = triads;
            
            if (prims && imm >= 0) {
                fprintf(file, " \"%s\"", prims[imm].name);
            } else {
                fprintf(file, " %d", imm);
            }
        } else if (op == BUND) {
            fprintf(file, " %d", blk_gets(prog, pc + 1));
        }
        fprintf(file, "\n");
        
        pc += oplens[op];
    }

    free(jump_targets);
    fclose(file);
}

lv*n_exit(lv*self,lv*a){(void)self;exit(ln(l_first(a)));}
lv*n_input(lv*self,lv*a){
	(void)self;char*line=bestline(drom_to_utf8(a->c<2?ls(l_first(a)): l_format(ls(l_first(a)),l_drop(ONE,a)))->sv);
	if(!line)return NONE;lv*r=lmutf8(line);free(line);return r;
}
lv*n_readwav(lv*self,lv*a){
	// this polyfill is limited compared to the version in decker, but avoids SDL dependencies:
	(void)self;lv*name=ls(l_first(a));int offset=a->c>1?MAX(0,ln(a->lv[1])):0, size=0;
	struct stat st;if(stat(name->sv,&st)||st.st_size<13)return sound_make(lms(size));
	char*data=calloc(size=st.st_size,1);FILE*f=fopen(name->sv,"rb");
	if(fread(data,1,st.st_size,f)!=(unsigned)st.st_size)return fclose(f),free(data),sound_make(lms(0));fclose(f);
	char HEAD[]={'R','I','F','F',0xFF,0xFF,0xFF,0xFF,'W','A','V','E','f','m','t',' ',16,0,0,0,1,0,1,0,64,31,0,0,64,31,0,0,1,0,8,0,'d','a','t','a'};
	for(int z=0;z<40&&z<size;z++)if(0xFF!=(0xFF&HEAD[z])&&HEAD[z]!=data[z])return free(data),sound_make(lms(0));
	int samples=((0xFF&data[43])<<24)|((0xFF&data[42])<<16)|((0xFF&data[41])<<8)|(0xFF&data[40]);
	lv*r=lms(CLAMP(0,samples-offset,10*SFX_RATE));EACH(z,r)r->sv[z]=0xFF&(data[44+z+offset]-128);
	return free(data),sound_make(r);
}
lv*n_readfile(lv*self,lv*a){
	lv*name=ls(l_first(a));
	if(a->c>1&&matchr(lmistr("array"),a->lv[1]))return readbin(name);
	if(has_suffix(name->sv,".gif" ))return n_readgif(self,a);
	if(has_suffix(name->sv,".wav" ))return n_readwav(self,a);
	if(has_suffix(name->sv,".deck"))return n_readdeck(self,a);
	return n_read(self,a);
}
lv*runstring(char*t,lv*env){
	lv* prog=parse(t);if(perr())return fprintf(stderr,"(%d:%d) %s\n",par.r+1,par.c+1,drom_to_utf8(lmcstr(par.error))->sv),NONE;
	return run(prog,env);
}
lv*runfile(char*path,lv*env){
	struct stat st;if(stat(path,&st)){fprintf(stderr,"unable to open '%s'\n",path);return NONE;}
	return runstring(n_read(NULL,l_list(lmcstr(path)))->sv,env);
}
lv* print_array(lv*arr,FILE*out){array a=unpack_array(arr);for(int z=0;z<a.size;z++)fputc(0xFF&(int)array_get_raw(a,z),out);return arr;}
lv*n_print(lv*self,lv*a){(void)self;return a->c==1&&array_is(a->lv[0])?print_array(l_first(a),stdout):n_printf(a,1,stdout);}
lv*n_error(lv*self,lv*a){(void)self;return a->c==1&&array_is(a->lv[0])?print_array(l_first(a),stderr):n_printf(a,1,stderr);}

extern char **environ;

void go_notify(lv*deck,lv*args,int dest){(void)deck,(void)args,(void)dest;}
void field_notify(lv*field){(void)field;}
lv* n_panic(lv*self,lv*z){(void)self,(void)z;return NONE;}
lv* n_alert(lv*self,lv*z){(void)self,(void)z;return ONE;}
lv* n_open (lv*self,lv*z){(void)self,(void)z;return lmistr("");}
lv* n_save (lv*self,lv*z){(void)self,(void)z;return NONE;}
lv* n_play (lv*self,lv*z){(void)self;lv*x=l_first(z);return x;}
lv* n_show(lv*self,lv*a){
	(void)self;str s=str_new();EACH(z,a){if(z)str_addc(&s,' ');show(&s,a->lv[z],a->c==1);}
	printf("%s\n",drom_to_utf8(lmstr(s))->sv);return l_first(a);
}
lv*interface_app(lv*self,lv*i,lv*x){
	if(!x&&lis(i)){
		ikey("show"      )return lmnat(n_show,NULL);
		ikey("print"     )return lmnat(n_print,NULL);
	}return x?x:NONE;(void)self;
}

// Environment

lv*n_import(lv*self,lv*a); // forward ref
lv* globals(void){
	lv*env=lmenv(NULL);
	dset(env,lmistr("show"     ),lmnat(n_show,NULL));
	dset(env,lmistr("print"    ),lmnat(n_print,NULL));
	dset(env,lmistr("error"    ),lmnat(n_error,NULL));
	dset(env,lmistr("input"    ),lmnat(n_input,NULL));
	dset(env,lmistr("dir"      ),lmnat(n_dir,NULL));
	dset(env,lmistr("read"     ),lmnat(n_readfile,NULL));
	dset(env,lmistr("write"    ),lmnat(n_writefile,NULL));
	dset(env,lmistr("path"     ),lmnat(n_path,NULL));
	dset(env,lmistr("exit"     ),lmnat(n_exit,NULL));
	dset(env,lmistr("shell"    ),lmnat(n_shell,NULL));
	dset(env,lmistr("eval"     ),lmnat(n_eval,NULL));
	dset(env,lmistr("import"   ),lmnat(n_import,NULL));
	dset(env,lmistr("random"   ),lmnat(n_random,NULL));
	dset(env,lmistr("array"    ),lmnat(n_array,NULL));
	dset(env,lmistr("image"    ),lmnat(n_image,NULL));
	dset(env,lmistr("sound"    ),lmnat(n_sound,NULL));
	dset(env,lmistr("newdeck"  ),lmnat(n_newdeck,NULL));
	dset(env,lmistr("readcsv"  ),lmnat(n_readcsv,NULL));
	dset(env,lmistr("writecsv" ),lmnat(n_writecsv,NULL));
	dset(env,lmistr("readxml"  ),lmnat(n_readxml,NULL));
	dset(env,lmistr("writexml" ),lmnat(n_writexml,NULL));
	constants(env);
	return env;
}
lv*n_import(lv*self,lv*a){
	lv*file=n_read(self,a);if(!file->c)return NONE;
	lv*prog=parse(ls(file)->sv);if(perr())return NONE;
	lv*root=lmenv(globals());pushstate(root),issue(root,prog);
	int c=0;while(running()){runop(),c++;if(c%100==0)lv_collect();}
	DMAP(r,root,root->lv[z]);return popstate(),r;
}

// Entrypoint

int main(int argc,char**argv){
	init_interns();
	lv* env=globals();
	lv* a=lml(argc);for(int z=0;z<argc;z++)a->lv[z]=lmutf8(argv[z]);
	dset(env,lmistr("args"),a);
	dset(env,lmistr("env"),env_enumerate());
	char*home=getenv("LIL_HOME");if(home){
		struct dirent*find;DIR*dir=opendir(home);if(dir){while((find=readdir(dir))){
			char path[4096];snprintf(path,sizeof(path),"%s/%s",home,find->d_name);
			if(has_suffix(path,".lil"))runfile(path,env);
		}}closedir(dir);
	}
	int repl=1;for(int z=1;z<argc;z++){
		if(!strcmp(argv[z],"-h")){repl=0;
			printf("usage: %s [FILE.lil...] [-e EXPR...] [-s]\nif present, execute a FILE and exit\n",argv[0]);
			printf("-e : evaluate STRING and exit\n-s : write bytecode to assembly file\n-h : display this information\n");
		}
		else if(!strcmp(argv[z],"-e")){repl=0;
			if(z+1>=argc)fprintf(stderr,"no expression specified.\n"),exit(1);
			runstring(argv[z+1],env),z++;
		}
		else if(!strcmp(argv[z],"-s")){
			if(z+1>=argc || !has_suffix(argv[z+1],".lil")){
				fprintf(stderr,"no .lil file specified for -s option.\n"),exit(1);
			}
			char* input_file = argv[z+1];
			char output_file[4096];
			snprintf(output_file, sizeof(output_file), "%s%s", input_file, "s");
			
			repl=0;
			lv* prog = parse(n_read(NULL, l_list(lmcstr(input_file)))->sv);
			if(perr()){
				fprintf(stderr, "(%d:%d) %s\n", par.r+1, par.c+1, drom_to_utf8(lmcstr(par.error))->sv);
				exit(1);
			}
			
			printf("Writing bytecode to %s\n", output_file);
			write_bytecode_to_assembly(prog, output_file);
			z++;
		}
		else if(has_suffix(argv[z],".lil")){repl=0;runfile(argv[z],env),z++;}
	}if(!repl){exit(0);}
	while(1){
		char*line=bestlineWithHistory(" ","lilt");
		if (!line)break;
		lv*prog=parse(lmutf8(line)->sv);free(line);
		if(perr()){for(int z=0;z<par.c+2;z++)printf(" ");printf("^\n%s\n",drom_to_utf8(lmcstr(par.error))->sv);}
		else{lv*x=run(prog,env);dset(env,lmistr("_"),x);debug_show(x);}
	}
}
