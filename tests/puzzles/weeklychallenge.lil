
# a series of Lil solutions to selected problems
# posed on the Perl Weekly Challenge:
# https://theweeklychallenge.org/

pn:problems:0
on problem x do
 problems:problems+1
 pn:x
end
on assert x y do
 if !x~y
  print["error in problem %f\ngot:       %j\nexpected:  %j" pn x y]
  exit[1]
 end
end

# utilities:

on rev       x do x @ (-1+count x)-range count x                    end # k: |:
on sortstr   x do "" fuse extract orderby value asc from x          end # k: {x@<x}
on sumscan   x do a:0 each v in x a:a+v end                         end # k: +\
on maxscan   x do a:0 each v in x a:a|v end                         end # k: |\

# the problems:

problem[296.1]
# compress the string x with run-length encoding
on f x do
 on run x do if 1~count x x else (count x),first x end end
 "" fuse extract run[value] by sumscan[1,!(1 drop value)=value] from x
end
assert[f["abbc"   ] "a2bc" ]
assert[f["aaabccc"] "3ab3c"]
assert[f["abcc"   ] "ab2c" ]

problem[293.1]
# how many dominoes are isomorphic?
on f x do
 max extract count index by value from (min@x)join(max@x)
end
assert[f["%j" parse "[[1, 3], [3, 1], [2, 4], [6, 8]]"        ] 2]
assert[f["%j" parse "[[1, 2], [2, 1], [1, 1], [1, 2], [2, 2]]"] 3]

problem[293.2]
# are all points distinct but also not in a straight line?
on f x do
 a:x[1]-x[0]
 b:x[2]-x[0]
 !(a[0]/a[1])=(b[0]/b[1])
end
assert[f["%j" parse "[[1, 1], [2, 3], [3, 2]]"] 1]
assert[f["%j" parse "[[1, 1], [2, 2], [3, 3]]"] 0]
assert[f["%j" parse "[[1, 1], [1, 2], [2, 3]]"] 1]
assert[f["%j" parse "[[1, 1], [1, 2], [1, 3]]"] 0]
assert[f["%j" parse "[[1, 1], [2, 1], [3, 1]]"] 0]
assert[f["%j" parse "[[0, 0], [2, 3], [4, 5]]"] 1]

problem[286.2]
# the "order game";
# repeatedly take alternate min/max of pairs of numbers until we're left with one
# (input is guaranteed to have a power-of-two >2 size)
on f x do
 first while 1<count x
  x:each p i in 2 window x if 2%i max p else min p end end
 end
end
assert[f[(0, 5, 3, 2)] 0]
assert[f[(2, 1, 4, 5, 6, 3, 0, 2)] 1]
assert[f[(9, 2, 1, 4, 5, 6, 0, 7, 3, 1, 3, 5, 7, 9, 0, 8)] 2]

problem[285.1]
# given a list of directed edges, find the node with no outgoing connection
# (this solution picks arbitrarily if there are multiple such nodes:)
on f x do first (first @ x) drop last @ x end
assert[f["%j" parse "[['B','C'],['D','B'],['C','A']]"] "A"]
assert[f["%j" parse "[['A','Z']]"                    ] "Z"]

problem[284.1]
# return an int with a frequency equal to its value or -1
on f x do
 max -1,extract where value=count gindex by value from x
end
assert[f[2,2,3,4    ]  2]
assert[f[1,2,2,3,3,3]  3]
assert[f[1,1,1,3    ] -1]

problem[283.1]
# find the one element in x that appears exactly one time
on f x do first extract where 1=count gindex by value from x end
assert[f[(3, 3, 1         )] 1]
assert[f[(3, 2, 4, 2, 4   )] 3]
assert[f[(list 1          )] 1]
assert[f[(4, 3, 1, 1, 1, 4)] 3]

problem[283.2]
# for every index i in the range [0<=i<count x], does the digit i occur exactly x[i] times?
on f x do x~sum x=list range count x end
assert[f[(1, 2, 1, 0)] 1]
assert[f[(0, 3, 0   )] 0]

problem[282.1]
# return a sequence of *exactly* 3 identical adjancent digits or -1
on f x do
 on perfect x do min x=first x end
 r:extract where perfect@value from -3 window "" split x
 if 1~count r "" fuse first r else -1 end
end
assert[f[12344456] "444"]
assert[f[ 1233334]    -1]
assert[f[10020003] "000"]

problem[282.2]
# how many times would you have to change letter keys to type x?
on f x do
 t:"" split "%l" format x
 sum !(1 drop t)=t
end
assert[f.pPeERrLl 3]
assert[f.rRr      0]
assert[f.GoO      1]

problem[281.1]
# is chess square x light?
on chess_coord x do ("%a" parse x)-97,49 end
on f x do 2%sum chess_coord[x] end
assert[f.d3 1]
assert[f.g5 0]
assert[f.e6 1]

problem[281.2]
# how many knight's moves between chess squares x and y?
on f x y do
 x:chess_coord[x] y:chess_coord[y]
 local d:"%j" parse "[[-2,-1],[-1,-2],[1,-2],[2,-1],[-2,1],[-1,2],[1,2],[2,1]]"
 local b:image[8,8]  b[x]:1
 while !b[y]
  local t:b.copy[].map[0,2 + range 255]
  each delta in d b.merge["|" t.copy[].translate[delta]] end
 end
 b[y]-1
end
assert[f["g2" "a8"] 4] # g2 -> e3 -> d5 -> c7 -> a8
assert[f["g2" "h2"] 3] # g2 -> e3 -> f1 -> h2

problem[280.1]
# find the first letter to appear twice
# (this is kinda ugly; is there a cleaner approach?)
on f x do
 v:() r:0
 each c in x
  if v[c]&!r r:c end
  v[c]:1
 end
 r
end
assert[f["acbddbca"] "d"]
assert[f["abccd"   ] "c"]
assert[f["abcdabbb"] "a"]

problem[280.2]
# count asterisks excluding those between a pair of pipes
on f x do
 sum "*" = "" split "" fuse first @ 2 window "|" split x
end
assert[f["p|*e*rl|w**e|*ekly|"          ] 2]
assert[f["perl"                         ] 0]
assert[f["th|ewe|e**|k|l***ych|alleng|e"] 5]

problem[279.1]
# sort the characters of a string x by weights y
on f x y do "" fuse extract orderby y asc from x end
assert[f["REPL"   (3,2,1,4    )] "PERL"  ]
assert[f["AURK"   (2,4,1,3    )] "RAKU"  ]
assert[f["OHYNPT" (5,4,2,6,1,3)] "PYTHON"]

problem[279.2]
# is there a split point which divides x into two strings containing the same number of vowels?
on f x do
 x:("" split x) in "aeiouy"
 max each i in range count x
  (sum i take x)~(sum i drop x)
 end
end
assert[f["perl"        ] 0]
assert[f["book"        ] 1]
assert[f["good morning"] 1]

problem[278.1]
# unsort words in a sentence x based on their trailing index digit
# (the parsing pattern is a little awkward, but it results in a nice clean query pipeline)
on f x do
 " " fuse extract c0 orderby c1 asc from table "%-.10r0123456789%i" parse " " split x
end
assert[f["and2 Raku3 cousins5 Perl1 are4"] "Perl and Raku are cousins"]
assert[f["guest6 Python1 most4 the3 popular5 is2 language7"] "Python is the most popular guest language"]
assert[f["Challenge3 The1 Weekly2"] "The Weekly Challenge"]

problem[278.2]
# sort characters of x ascending up to the first occurrence of y (if any)
on f x y do
 i:1+first extract index where value=y from x
 "" fuse (extract orderby value asc from i take x),i drop x
end
assert[f["challenge"   "e"] "acehllnge"  ]
assert[f["programming" "a"] "agoprrmming"]
assert[f["champion"    "b"] "champion"   ]

problem[277.1]
# how many strings appear exactly once in both x and y?
on f x y do
 on once x do extract value where 1=count gindex by value from x end
 count once[x] take once[y]
end
assert[f[("Perl", "is", "my", "friend") ("Perl", "and", "Raku", "are", "friend")] 2]
assert[f[("Perl", "and", "Python", "are", "very", "similar") ("Python", "is", "top", "in", "guest", "languages")] 1]
assert[f[("Perl", "is", "imperative", "Lisp", "is", "functional") ("Crystal", "is", "similar", "to", "Ruby")] 0]

problem[276.1]
# how many pairs of elements from x form a multiple of 24?
on f x do
 sum each a i in x
  sum 0=24%a+(i+1)drop x
 end
end
assert[f[(12,12,30,24,24)] 2]
assert[f[(72,48,24,5    )] 3]
assert[f[(12,18,24      )] 0]

problem[276.2]
# how many elements of x have the maximum frequency?
on f x do
 r:extract count value by value from x
 sum r*r=max r
end
assert[f[(1,2,2,4,1,5)] 4]
assert[f[(1,2,3,4,5  )] 5]

problem[275.1]
# how many words in a sentence x can be typed with broken keyboard keys y?
on f x y do
 sum each w in " " split "%l" format x !max y in w end
end
assert[f["Perl Weekly Challenge"    ("l","a" )] 0]
assert[f["Perl and Raku"            (list "a")] 1]
assert[f["Well done Team PWC"       ("l","o") ] 2]
assert[f["The joys of polyglottism" (list "t")] 2]

problem[275.2]
# replace each digit in the given string with the value of the previous letter plus (digit) places.
on f x do
 local l:0
 "" fuse each c in x
  if c like "#" "%a" format c+"%a" parse l else l:c end
 end
end
assert[f["a1c1e1"  ] "abcdef"  ]
assert[f["a1b2c3d4"] "abbdcfdh"]
assert[f["b2b"     ] "bdb"     ]
assert[f["a16z"    ] "abgz"    ]

problem[274.1]
# translate a sentence into "goat-latin":
# - If a word begins with a vowel ("a", "e", "i", "o", "u"), append "ma" to the end of the word.
# - If a word begins with consonant i.e. not a vowel, remove first letter and append it to the end then add "ma".
# - Add letter "a" to the end of first word in the sentence, "aa" to the second word, etc etc.
on f x do
 " " fuse each word i in " " split x
  if (first word) in "aeiouyAEIOUY" word else (1 drop word),(first word) end,"m",(i+2) take "a"
 end
end
assert[f["I love Perl"              ] "Imaa ovelmaaa erlPmaaaa"                           ]
assert[f["Perl and Raku are friends"] "erlPmaa andmaaa akuRmaaaa aremaaaaa riendsfmaaaaaa"]
assert[f["The Weekly Challenge"     ] "heTmaa eeklyWmaaa hallengeCmaaaa"                  ]

problem[273.1]
# return the percentage (nearest whole) of a given character in x
# this one's slightly tricky because lil doesn't have a 'round' primitive:
on f c x do
 floor 100*0.005+(sum c="" split x)/count x
end
assert[f["e" "perl"     ] 25]
assert[f["a" "java"     ] 50]
assert[f["m" "python"   ]  0]
assert[f["a" "ada"      ] 67]
assert[f["l" "ballerina"] 22]
assert[f["k" "analitik" ] 13]

problem[273.2]
# return true if there is at least one "b", and no "a" appears after the first "b"
on f x do ("b" in x)&!x like "*b*a*" end
assert[f["aabb"] 1]
assert[f["abab"] 0]
assert[f["aaa" ] 0]
assert[f["bbb" ] 1]

problem[272.1]
# replace every period ("."") in an IP address with "[.]"
on f x do "[.]" fuse "." split x end
assert[f["1.1.1.1"    ] "1[.]1[.]1[.]1"    ]
assert[f["255.101.1.0"] "255[.]101[.]1[.]0"]

problem[272.2]
# calculate the sum of the absolute difference between the ASCII values of adjacent characters in x.
on f x do
  t:"%a" parse x
  sum mag@(1 drop t)-t
end
assert[f["hello"] 13]
assert[f["perl" ] 30]
assert[f["raku" ] 37]

problem[271.1]
# find the row number (1-indexed) of a matrix containing maximum ones
on f x do 1+first extract index orderby sum@value desc from x end
assert[f["%j" parse "[[0,1],[1,0]]"      ] 1]
assert[f["%j" parse "[[0,0,0],[1,0,1]]"  ] 2]
assert[f["%j" parse "[[0,0],[1,1],[0,0]]"] 2]

problem[271.2]
# sort the integers in x in ascending order by the number of 1 bits in their binary representation,
# breaking ties by their value.
on f x do
  masks:2^range 32
  on onebits x do sum!!bits.and[x masks] end
  extract orderby onebits@value asc orderby value asc from x
end
assert[f[(0,1,2,3,4,5,6,7,8  )] (0,1,2,4,8,3,5,6,7  )]
assert[f[(1024,512,256,128,64)] (64,128,256,512,1024)]

problem[270.1]
# how many 1s in a matrix have no 1s in the same row or column?
on f x do (sum 1=sum x)&(sum 1=sum@x) end
assert[f["%j" parse "[[1,0,0],[0,0,1],[1,0,0]]"] 1]
assert[f["%j" parse "[[1,0,1],[0,0,0],[0,1,0]]"] 1]
assert[f["%j" parse "[[1,0,0],[0,1,0],[0,0,1]]"] 3]

problem[269.1]
# are there at least two numbers in x whose bitwise OR has a trailing 0 digit in binary?
# (this is, of course, simply asking if there are at least two even numbers!)
on f x do 1<sum 0=2%x end
assert[f[(1,2,3,4,5)] 1]
assert[f[(2,3,8,16 )] 1]
assert[f[(1,2,5,7,9)] 0]

problem[268.1]
# ignoring order, what number could be added to x to get y?
on f x y do (min y)-(min x) end
assert[f[(3,7,5)  (9,5,7) ] 2]
assert[f[(1,2,1)  (5,4,4) ] 3]
assert[f[(list 2) (list 5)] 3]
assert[f[      2        5 ] 3] # as a bonus...

problem[268.2]
# sort x ascending, with each pair descending.
# like many weird sorting problems, this one really showcases generalized clause order!
on f x do
  extract orderby value desc by floor gindex/2 orderby value asc from x
end
assert[f[(2,5,3,4        )] (3,2,5,4        )]
assert[f[(9,4,1,3,6,4,6,1)] (1,1,4,3,6,4,9,6)]
assert[f[(1,2,2,3        )] (2,1,3,2        )]

problem[267.1]
# find the sign of product of all integers in x
on f x do t:prod x  t/mag t end
assert[f[(-1, -2, -3, -4, 3, 2, 1)]  1]
assert[f[(1, 2, 0, -2, -1        )]  0]
assert[f[(-1, -1, 1, -1, 2       )] -1]

problem[267.2]
# calculate the lines/last-line-width of a string wrapped
# at 100 units wide given a list of character widths.
on f str wids do
  local y:1 local x:0
  each w in ("abcdefghijklmnopqrstuvwxyz"dict wids)@str
   if 100<x+w y:y+1 x:w else x:x+w end
  end
  y,x
end
assert[f[
  "abcdefghijklmnopqrstuvwxyz"
  (10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10)
] (3,60)]
assert[f[
  "bbbcccdddaaa"
  (4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10)
] (2,4)]

problem[266.1]
# find any words that appear exactly once among two sentences
on f x y do
 extract where 1=count index by value from " "split x," ",y
end
assert[f["Mango is sweet" "Mango is sour"   ] ("sweet","sour")]
assert[f["Mango Mango"    "Orange"          ] (list "Orange" )]
assert[f["Mango is Mango" "Orange is Orange"] ()              ]

problem[266.2]
# is a square matrix non-zero only along the main diagonals?
on f x do
  n:count x  # loosely, {(!!x)~t||t:(!n)=/:|!n:#x}
  each v in range n (v=range n)|v=(n-1)-range n end~!!x
end
assert[f["%j" parse "[[1,0,0,2],[0,3,4,0],[0,5,6,0],[7,0,0,1]]"] 1]
assert[f["%j" parse "[[1,2,3],[4,5,6],[7,8,9]]"                ] 0]
assert[f["%j" parse "[[1,0,2],[0,3,0],[4,0,5]]"                ] 1]

problem[263.1]
# find indices of sorted elements of x equal to k
# demonstrates a "glottal stop" in chained queries
# which could potentially be removed if we could define
# new columns in-flight within a query pipeline...
on f k x do
  extract index where value=k from select orderby value asc from x
end
assert[f[2 (1,5,3,2,4,2)] (1,2   )]
assert[f[6 (1,2,4,3,5  )] (      )]
assert[f[4 (5,3,2,4,2,1)] (list 4)]

problem[263.2]
# merge lists of (id,quantity) pairs.
on f x y do
  extract list(first c0),sum c1 by c0 from table x,y
end
assert[f["%j" parse "[[1,1],[2,1],[3,2]]"
         "%j" parse "[[2,2],[1,3]]"      ]
         "%j" parse "[[1,4],[2,3],[3,2]]"]
assert[f["%j" parse "[[1,2],[2,3],[1,3],[3,2]]"
         "%j" parse "[[3,1],[1,3]]"      ]
         "%j" parse "[[1,8],[2,3],[3,3]]"]
assert[f["%j" parse "[[1,1],[2,2],[3,3]]"
         "%j" parse "[[2,3],[2,4]]"      ]
         "%j" parse "[[1,1],[2,9],[3,3]]"]

problem[262.1]
# maximum of the count of positive or negative integers in x
on f x do (sum x<0)|(sum x>0) end
assert[f[(-3, 1, 2, -1, 3, -2, 4)] 4]
assert[f[(-1, -2, -3, 1         )] 3]
assert[f[(1,2                   )] 2]

problem[262.2]
# count pairs of indices to x where x[i]==x[j], i<j, and k divides i*j
on f k x do
  sum each xi i in x
    sum each xj j in x
      (xi~xj)&(i<j)&!k%i*j
    end
  end
end
assert[f[2 (3,1,2,2,2,1,3)] 4]
assert[f[1 (1,2,3)        ] 0]

problem[261.1]
# compute the absolute difference between element and digit sum of x
on f x do mag(sum x)-sum""split""fuse x end
assert[f[(1,2,3,45          )]   36]
assert[f[(1,12,3            )]    9]
assert[f[(1,2,3,4           )]    0]
assert[f[(236, 416, 336, 350)] 1296]

problem[261.2]
# multiply s by 2 while it is in the set x
on f s x do while s in x s:2*s end s end
assert[f[3 (5,3,6,1,12)] 24]
assert[f[1 (1,2,4,3   )]  8]
assert[f[2 (5,6,7     )]  2]

problem[260.1]
# are the number of occurrences for each digit in an array distinct?
on f x do
 t:extract count value by value from x
 t~keys t dict 0
end
assert[f[(1,2,2,1,1,3           )] 1]
assert[f[(1,2,3                 )] 0]
assert[f[(-2,0,1,-2,1,1,0,1,-2,9)] 1]

problem[259.2]
# parse a dictionary-literal-like line format
on f x do
 r.name:first h:"{%%%*r %v%*r %n" parse x
 i:last h while last t:"%v=%j%*r %n" parse i drop x  i:i+t[2]  r.fields[t[0]]:t[1] end r
end
assert[f["{%  id   field1=\"value1\"    field2=\"value2\"  field3=42 %}"]
  "%j" parse "{'name':'id','fields':{'field1':'value1','field2':'value2','field3':42}}"
]
assert[f["{%  youtube title=\"Title \\\"quoted\\\" done\" %}"]
  "%j" parse "{'name':'youtube','fields':{'title':'Title \"quoted\" done'}}"
]

problem[257.1]
# how many elements of x are smaller than each element of x?
on f x do
 each v in x sum x<v end
end
assert[f[(5, 2, 1, 6)] (2, 1, 0, 3)]
assert[f[(1, 2, 0, 3)] (1, 2, 0, 3)]
assert[f[(0, 1      )] (0, 1      )]
assert[f[(9, 4, 9, 2)] (2, 1, 2, 0)]

problem[255.1]
# find the 'extra' character in y, compared to x
# (see 130.1, except we have to convert ascii->numbers->ascii)
on f x y do
 "%a" format bits.xor[raze "%a" parse x,y]
end
assert[f["Perl"   "Preel"  ] "e"]
assert[f["Weekly" "Weeakly"] "a"]
assert[f["Box"    "Boxy"   ] "y"]

problem[255.2]
# find the most frequent word in x, except for y
# (I'm kinda cheating by only handling . and , as punctuation.)
on f x y do
  first extract orderby c desc from
        select v:first value c:count value by value from y drop" "split (",",".")drop x
end
assert[f["Joe hit a ball, the hit ball flew far after it was hit." "hit"] "ball"]
assert[f["Perl and Raku belong to the same family. Perl is the most popular language in the weekly challenge." "the"] "Perl"]

problem[254.2]
# reverse the vowels in the given string, preserving the order of casing.
on f x do
 on zipcase a b do each v i in a ("%l","%u")[v in "AEIOUY"]format b[i] end end
 "" fuse first cols update value:zipcase[value rev[value]] where value in "aeiouyAEIOUY" from x
end
assert[f["Raku" ] "Ruka" ]
assert[f["Perl" ] "Perl" ]
assert[f["Julia"] "Jaliu"]
assert[f["Uiua" ] "Auiu" ]

problem[253.1]
# split all words in a list by a delimiter, excluding empty strings
on f sep x do
 extract where count@value from sep split sep fuse x
end
assert[f["." ("one.two.three","four.five","six")] ("one","two","three","four","five","six")]
assert[f["$" ("$perl$$", "$$raku$"             )] ("perl","raku")                          ]

problem[253.2]
# in a 0/1 matrix where 1s always appear in contiguous left-aligned spans,
# grade rows from "weakest" to "strongest",
# where stronger rows contain more 1s OR have a greater original index.
# (we can take advantage of both lexicographic ordering and sort stability)
on f x do
 extract index orderby value asc from x
end
assert[f["%j" parse "[
 [1, 1, 0, 0, 0],
 [1, 1, 1, 1, 0],
 [1, 0, 0, 0, 0],
 [1, 1, 0, 0, 0],
 [1, 1, 1, 1, 1]
]"] (2, 0, 3, 1, 4)]
assert[f["%j" parse "[
 [1, 0, 0, 0],
 [1, 1, 1, 1],
 [1, 0, 0, 0],
 [1, 0, 0, 0]
]"] (0, 2, 3, 1)]

problem[250.1]
# find the minimum index i in x where x=10%i
# demonstrates a convenient idiom for failing over to a default
# value when a query doesn't produce any filtered rows.
on f x do first extract index,-1 where value=10%index from x end
assert[f[(0, 1, 2                     )]  0]
assert[f[(4, 3, 2, 1                  )]  2]
assert[f[(1, 2, 3, 4, 5, 6, 7, 8, 9, 0)] -1]

problem[250.2]
# find the maximum string value in x, where digit-only strings are their decimal value, and others are their count
on f x do
  on sval x do if min(""split x)in"0123456789" 0+x else count x end end
  max sval @ x
end
assert[f[("perl", "2", "000", "python", "r4ku")] 6]
assert[f[("001", "1", "000", "0001"           )] 1]

problem[248.1]
# find the distance of each position in a string x from the closest instance of a character y.
on f x y do
 m:!("" split x)=y
 on fscan x do r:1000000 each v in x r:v*1+r end end
 fscan[m]&rev[fscan[rev[m]]]
end
assert[f["loveleetcode" "e"] (3,2,1,0,1,0,0,1,2,2,1,0)]
assert[f["aaab"         "b"] (3,2,1,0)]

problem[247.2]
# find the bi-gram which occurs most frequently, breaking ties by lexicographic order
on f x do
 first extract orderby v asc by c orderby c desc from
       select v:first value c:count value by value from -2 window x
end
assert[f["abcdbca"          ] "bc"]
assert[f["cdeabeabfcdfabgcd"] "ab"]

problem[245.1]
# sort x by y
on f x y do extract orderby y asc from x end
assert[f[("perl","c","python")    (2,1,3)] ("c","perl","python")]
assert[f[("c++","haskell","java") (1,3,2)] ("c++","java","haskell")]

problem[242.1]
# find the (distinct) members of x missing from y.
on missing x y do extract first value by value where !value in y from x end
on f x y do (list missing[x y]),list missing[y x] end
assert[f[(1,2,3)   (2,4,6)  ] "%j"parse"[[1,3],[4,6]]"]
assert[f[(1,2,3,3) (1,1,2,2)] "%j"parse"[[3],[]]     "]

problem[242.2]
# given a matrix, reverse each row and invert values.
on f x do rev @ ! x end
assert[f["%j" parse "[[1,1,0],[1,0,1],[0,0,0]]"                ] "%j"parse"[[1,0,0],[0,1,0],[1,1,1]                ]"]
assert[f["%j" parse "[[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]"] "%j"parse"[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]"]

problem[240.1]
# are y an acronym of the letters x?
on f x y do x~("","%l")format first@y end
assert[f["ppp" ("Perl", "Python", "Pascal")] 1]
assert[f["rp"  ("Perl", "Raku"            )] 0]
assert[f["oac" ("Oracle", "Awk", "C"      )] 1]

problem[239.1]
# is the word created by concatenating the array elements is the same?
on f x y do(""fuse x)~""fuse y end
assert[f[("ab", "c") ("a", "bc")    ] 1]
assert[f[("ab", "c") ("ac", "b")    ] 0]
assert[f[("ab", "cd", "e") ("abcde")] 1]

problem[239.2]
# how many strings y are formed exclusively from x?
on f x y do sum each v in y min("" split v)in x end end
assert[f["ab"  ("ad", "bd", "aaab", "baa", "badab"             )] 2]
assert[f["abc" ("a", "b", "c", "ab", "ac", "bc", "abc"         )] 7]
assert[f["cad" ("cc", "acd", "b", "ba", "bac", "bad", "ac", "d")] 4]

problem[238.1]
# return the running sum of the given array.
assert[sumscan[(1, 2, 3, 4, 5)] (1, 3, 6, 10, 15)]
assert[sumscan[(1, 1, 1, 1, 1)] (1, 2, 3, 4, 5  )]
assert[sumscan[(0, -1, 1, 2  )] (0, -1, 0, 2    )]

problem[238.2]
# sort the given array in increasing order with respect to the count of steps required
# to obtain a single-digit number by multiplying its digits recursively for each array element.
# If any two numbers have the same count of steps, then print the smaller number first.
on stp x do if x<10 0 else 1+stp[prod""split x] end end
on f x do extract orderby (stp@value)join value asc from x end
assert[f[(15, 99, 1, 34 )] (1, 15, 34, 99 )]
assert[f[(50, 25, 33, 22)] (22, 33, 50, 25)]

problem[236.1]
# can you form exact change for all $5 purchases given a stream of bills x?
on f x do
 a:b:0 r:1 each v in x
  if v~10 a:a+1 end
  if v~5  b:b+1 end
  c:v-5 while c&r
   if     c~0
   elseif a&!c<10 a:a-1 c:c-10
   elseif b&!c< 5 b:b-1 c:c- 5 
   else   r:0 end
  end
 end
 r
end
assert[f[(5, 5,  5, 10, 20)] 1]
assert[f[(5, 5, 10, 10, 20)] 0]
assert[f[(5, 5,  5, 20    )] 1]

problem[233.2]
# sort the given array in increasing order based on the frequency of the values.
# if multiple values have the same frequency then sort them in decreasing order.
on f x do
 extract orderby c asc orderby v desc from
  select v:value c:count value by value from x
end
assert[f[(1,1,2,2,2,3         )] (3,1,1,2,2,2         )]
assert[f[(2,3,1,3,2           )] (1,3,3,2,2           )]
assert[f[(-1,1,-6,4,5,-6,1,4,1)] (5,-1,4,4,-6,-6,1,1,1)]

problem[230.1]
# separate the given array into single digits.
on f x do 0+""split x end
assert[f[(1, 34, 5, 6  )] (1, 3, 4, 5, 6      )]
assert[f[(1, 24, 51, 60)] (1, 2, 4, 5, 1, 6, 0)]

problem[230.2]
# return the count of words that start with the given prefix.
on f prefix x do sum x like "%s*" format prefix end
assert[f["at" ("pay", "attention", "practice", "attend")] 2]
assert[f["ja" ("janet", "julia", "java", "javascript"  )] 3]

problem[220.1]
# return the list of common characters (sorted alphabetically) found in every word of the given list.
on f x do
 extract orderby value asc where min each y in x c in y end from c:"" split first x
end
assert[f[("perl", "rust", "raku" )] (list "r"   )]
assert[f[("love", "live", "leave")] ("e","l","v")]

problem[219.1]
# square each number in the list and return the sorted list, increasing order.
on f x do extract orderby value asc from x^2 end
assert[f[(-2, -1, 0, 3, 4)] (0, 1, 4, 9, 16  )]
assert[f[(5, -4, -1, 3, 6)] (1, 9, 16, 25, 36)]

problem[217.1]
# find the 3rd smallest element in the sorted matrix.
on f x do first 2 drop extract orderby value asc from raze x end
assert[f["%j" parse "[[3, 1, 2], [5, 2, 4], [0, 1, 3]]"] 1]
assert[f["%j" parse "[[2, 1], [4, 5]]"                 ] 4]
assert[f["%j" parse "[[1, 0, 3], [0, 0, 0], [1, 2, 1]]"] 0]

problem[215.1]
# count words in the list that are not alphabetically sorted.
on f x do count extract where !value=sortstr@value from x end
assert[f[("abc","xyz","tsu")] 1]
assert[f[("rat","cab","dad")] 3]
assert[f[("x","y","z"      )] 0]

problem[213.1]
# sort the all even integers first then all odds in ascending order.
on f x do extract orderby (2%value) join value asc from x end
assert[f[(1,2,3,4,5,6)] (2,4,6,1,3,5)]
assert[f[(1,2        )] (2,1        )]
assert[f[(list 1     )] (list 1     )]

problem[206.1]
# find the shortest time in minutes between any two time points.
on f x do
 t:extract orderby value asc from sum(60,1)*flip "%i:%i" parse x
 min each v i in t (24*60)%t[(count t)%i+1]-v end
end
assert[f[("00:00", "23:55", "20:00"         )]  5]
assert[f[("01:01", "00:50", "00:57"         )]  4]
assert[f[("10:10", "09:30", "09:00", "09:55")] 15]

problem[205.2]
# find the highest value obtained by XORing any two distinct members of the array.
on f x do max each p in x cross x bits.xor[p] end end
assert[f[(1,2,3,4,5,6,7)]  7]
assert[f[(2,4,1,3      )]  7]
assert[f[(10,5,7,12,8  )] 15]

problem[204.1]
# is array monotonically increasing OR decreasing?
on f x do
 (min!(1 drop x)>x)|
  min!(1 drop x)<x
end
assert[f[(1,2,2,3)] 1]
assert[f[(1,3,2  )] 0]
assert[f[(6,5,5,4)] 1]

problem[199.1]
# count 'good pairs' (i,j) where i<j and x[i]==x[j]
on f x do
 r:()
 each xj j in x
  each xi i in j take x
   if xi=xj r:r,list i,j end
  end
 end
 count r
end
assert[f[(1,2,3,1,1,3)] 4]
assert[f[(1,2,3      )] 0]
assert[f[(1,1,1,1    )] 6]

problem[197.1]
# move all zeros to the end while maintaining the relative order of non-zero elements.
on f x do ((z:list 0)drop x),z take x end
assert[f[(1, 0, 3, 0, 0, 5)] (1, 3, 5, 0, 0, 0)]
assert[f[(1, 6, 4         )] (1, 6, 4         )]
assert[f[(0, 1, 0, 2, 0   )] (1, 2, 0, 0, 0   )]

problem[191.1]
# find out whether the largest item in the list is at least twice as large as each of the other items.
on f x do (-1,1)[min!(m:max x)<2*(list m)drop x] end
assert[f[(1,2,3,4)] -1]
assert[f[(1,2,0,5)]  1]
assert[f[(2,6,3,1)]  1]
assert[f[(4,5,2,3)] -1]

problem[189.1]
# find the smallest character in the given array lexicographically greater than the target character.
on f target x do target unless first extract orderby value asc where value>target from x end
assert[f["b" "emug"] "e"]
assert[f["a" "dcef"] "c"]
assert[f["o" "jar" ] "r"]
assert[f["a" "dcaf"] "c"]
assert[f["v" "tgal"] "v"]

problem[186.1]
# intercalate items of a pair of lists.
on f a b do raze a join b end
assert[f[(1,2,3) ("a","b","c")] (1,"a",2,"b",3,"c")]
assert[f[("a","b","c") (1,2,3)] ("a",1,"b",2,"c",3)]

problem[185.1]
# convert a MAC address from hhhh.hhhh.hhhh to hh:hh:hh:hh:hh:hh
on f x do "%2h:%2h:%2h:%2h:%2h:%2h"format"%2h%2h.%2h%2h.%2h%2h"parse x end
assert[f["1ac2.34f0.b1c2"] "1a:c2:34:f0:b1:c2"]
assert[f["abc1.20f1.345a"] "ab:c1:20:f1:34:5a"]

problem[184.1]
# given a list of strings, replace the first two chars with a sequence number.
on f x do each v i in x "%02i%s" format i,2 drop v end end
assert[f[("ab1234","cd5678","ef1342")] ("001234","015678","021342")]
assert[f[("pq1122","rs3334"         )] ("001122","013334"         )]

problem[183.1]
# remove duplicate sublists from a list.
on f x do keys x dict () end
assert[f["%j"parse"[[1,2],[3,4],[5,6],[1,2]]"] "%j"parse"[[1,2],[3,4],[5,6]]"]
assert[f["%j"parse"[[9,1],[3,7],[2,5],[2,5]]"] "%j"parse"[[9,1],[3,7],[2,5]]"]

problem[182.1]
# find the index of the first biggest number in the list.
on f x do first extract index orderby value desc from x end
assert[f[(5, 2, 9, 1, 7, 6)] 2]
assert[f[(4, 2, 3, 1, 5, 0)] 4]

problem[181.1]
# order each sentence alphanumerically in a paragraph.
on f x do
 "."fuse each s in "."split x
  " "fuse extract orderby (list "%l")format value asc from " "split s
 end
end
assert[
f["All he could think about was how it would all end. There was still a bit of uncertainty in the equation, but the basics were there for anyone to see. No matter how much he tried to see the positive, it wasn't anywhere to be seen. The end was coming and it wasn't going to be pretty."]
  "about All all could end he how it think was would. a anyone basics bit but equation, for in of see still the the There there to uncertainty was were. anywhere be he how it matter much No positive, see seen the to to tried wasn't. and be coming end going it pretty The to was wasn't."
]

problem[181.2]
# find days with a temperature hotter than the previous
on f x do extract where temp>(first temp),temp orderby date asc from readcsv["date,temp\n",x "si"] end
assert[
f["2022-08-01, 20
2022-08-09, 10
2022-08-03, 19 
2022-08-06, 24
2022-08-05, 22
2022-08-10, 28
2022-08-07, 20
2022-08-04, 18
2022-08-08, 21
2022-08-02, 25"]
 ("2022-08-02","2022-08-05","2022-08-06","2022-08-08","2022-08-10")
]

problem[180.1]
# find the index of the first unique character.
on f x do first extract index where 1~count value by value from x end
assert[f["Perl Weekly Challenge"] 0]
assert[f["Long Live Perl"       ] 1]

problem[180.2]
# find the numbers in a list greater than an integer.
on f x i do extract where value>i from x end
assert[f[(1,4,2,3,5)     3] (4,5    )]
assert[f[(9,0,6,2,3,8,5) 4] (9,6,8,5)]

problem[179.1]
# convert an integer into ordinal english words.
# (range unspecified, so handle 0 to 9999)
on f x do
 o:"|"split"||twen|thir|four|fif|six|seven|eigh|nine"
 s:"|"split"zeroth|first|second|third|fourth|fifth|sixth|seventh|eighth|ninth|tenth|eleventh|twelfth"
 i:"|"split"|one|two|three|four|five|six|seven|eight|nine"
 if     (x>999)&0~1000%x "%s-thousandth"  format i[x/1000]
 elseif x>999            "%s-thousand %s" format i[x/1000],f[1000%x]
 elseif (x>99)&0~100%x   "%s-hundredth"   format i[x/100]
 elseif x>99             "%s-hundred %s"  format i[x/100],f[100%x]
 elseif x<13 s[x]
 elseif x<20             "%steenth"       format o[x-10]
 elseif 0~10%x           "%stieth"        format o[x/10]
 elseif x>13             "%sty-%s"        format o[x/10],f[10%x]
 end
end
assert[f[11] "eleventh"]
assert[f[62] "sixty-second"]
assert[f[99] "ninety-ninth"]

problem[165.1]
# generate an .svg of dots and lines
# (which speak and say: what we do is what you wish to do!)
on svg shapes do
  b.tag:"svg"
  b.attr:("xmlns","width","height")dict"http://www.w3.org/2000/svg","100%","100%"
  v:raze each v in shapes (list 2 take v),(list -2 take v) end
  b.attr.viewBox:"%i %i %i %i"format(ap:min v),(max v)-ap 
  b.children:each s in shapes
    r.tag:"path"
    r.attr["stroke-width"]:2
    if 2~count s
      r.attr.d:"M %f %f a 2 2 0 1 0 1 0 Z"format s
      r.attr.fill:"orange"
    else
      r.attr.d:"M %f %f L %f %f Z"format s
      r.attr.stroke:"royalblue"
    end
  end
  writexml[b]
end
on fit_line x do # calculate a line-of-best-fit via the least-squares method:
  n:count x
  sf:sum ff:first f:flip x
  m:((n*sum prod f)-prod sum x)/(n*sum ff^2)-sf^2
  b:(1/n)*(sum last f)-m*sf
  on pt x do x,b+m*x end
  list pt[min ff],pt[max ff]
end
p:"%j" parse "[
  [333,129],[ 39,189],[140,156],[292,134],[393,52 ],[160,166],[362,122],[ 13,193],
  [341,104],[320,113],[109,177],[203,152],[343,100],[225,110],[ 23,186],[282,102],
  [284,98 ],[205,133],[297,114],[292,126],[339,112],[327,79 ],[253,136],[ 61,169],
  [128,176],[346,72 ],[316,103],[124,162],[ 65,181],[159,137],[212,116],[337, 86],
  [215,136],[153,137],[390,104],[100,180],[ 76,188],[ 77,181],[ 69,195],[ 92,186],
  [275,96 ],[250,147],[ 34,174],[213,134],[186,129],[189,154],[361,82 ],[ 363,89],
]"
assert[
  svg[p,fit_line[p]]
  "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"13 52 380 144\"><path stroke-width=\"2\" d=\"M 333 129 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 39 189 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 140 156 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 292 134 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 393 52 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 160 166 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 362 122 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 13 193 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 341 104 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 320 113 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 109 177 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 203 152 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 343 100 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 225 110 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 23 186 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 282 102 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 284 98 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 205 133 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 297 114 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 292 126 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 339 112 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 327 79 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 253 136 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 61 169 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 128 176 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 346 72 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 316 103 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 124 162 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 65 181 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 159 137 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 212 116 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 337 86 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 215 136 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 153 137 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 390 104 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 100 180 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 76 188 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 77 181 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 69 195 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 92 186 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 275 96 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 250 147 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 34 174 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 213 134 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 186 129 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 189 154 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 361 82 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 363 89 a 2 2 0 1 0 1 0 Z\" fill=\"orange\"/><path stroke-width=\"2\" d=\"M 13 196.232838 L 393 82.249368 Z\" stroke=\"royalblue\"/></svg>"
]

problem[163.1]
# sum of bitwise AND of all unique pairs.
on f x do sum extract bits.and[c0 c1] where c0<c1 from table x cross x end
assert[f[1,2,3] 3] # (1 & 2) + (2 & 3) + (1 & 3) => 0 + 2 + 1 =>  3
assert[f[2,3,4] 2] # (2 & 3) + (2 & 4) + (3 & 4) => 2 + 0 + 0 =>  2

problem[162.1]
# calculate isbn-13 check-digit.
on f x do 10%10-10%sum(12 take"-"drop x)*1,3 end
assert[f["978-0-306-40615"] 7]
assert[f["978-3-16-148410"] 0]
assert[f["978-1-86197-876"] 9]

problem[160.1]
# take a number<10, convert to cardinal, count letters, and iterate until you reach "four".
on f x do
 d:count@n:"|"split"|one|two|three|four|five|six|seven|eight|nine"
 r:list x while !d[x]~4 x:d[x] r:r,x end
 " "fuse each v in r "%s is %s,"format n[v],n[d[v]] end,"four is magic."
end
assert[f[5] "five is four, four is magic."                             ]
assert[f[7] "seven is five, five is four, four is magic."              ]
assert[f[6] "six is three, three is five, five is four, four is magic."]

problem[145.1]
# calculate the dot-product of two lists.
on f x y do sum x*y end
assert[f[(1,2,3) (4,5,6)] 32]

problem[143.1]
# evaluate mathematical expressions of numbers, (), and + - * /
on f x do
  x:""fuse" "drop x
  on m t do if last r:("%s%%n"format t)parse x  x:(last r)drop x  first r end end
  on ex1 do
   t:if m["("] r:ex2[] m[")"] r else m["%i"] end
   if     m["*"] t*ex1[]
   elseif m["/"] t/ex2[]
   else t end
  end
  on ex2 do
   t:ex1[]
   if     m["+"] t+ex2[]
   elseif m["-"] t-ex2[]
   else t end
  end
  ex2[]
end
assert[f["10 + 20 - 5"      ] 25]
assert[f["(10 + 20 - 5) * 2"] 50]
assert[f["3 * 2 + 5"        ] 11]

problem[139.1]
# return 1 iff an array is already sorted.
on f x do min(1 drop x)>x end
assert[f[(1,2,3,4,5)] 1]
assert[f[(1,3,2,4,5)] 0]

problem[134.2]
# generate a multiplcation table and display count of distinct terms.
# (took some liberties with the display format here)
on f m n do
 t:(1+range m)*list 1+range n
 d:extract first value by value from raze t
 w:floor 2+(1/ln 10)*ln max t
 c:("","%%%ii")format w
 "\n"fuse("\n x |%s"format c format first t),
         (" --+%s"format (sum w)take"-"),
         (("\n"," %%i |%s"format c)format(1+range m)join t),
         ("\ndistinct terms: %j" format list d),
         ("count: %i" format count d)
end
assert[f[3 3] "
 x | 1 2 3
 --+------
 1 | 1 2 3
 2 | 2 4 6
 3 | 3 6 9

distinct terms: [1,2,3,4,6,9]
count: 6"
]
assert[f[3 5] "
 x | 1 2 3  4  5
 --+------------
 1 | 1 2 3  4  5
 2 | 2 4 6  8 10
 3 | 3 6 9 12 15

distinct terms: [1,2,3,4,5,6,8,10,9,12,15]
count: 11"
]

problem[131.1]
# return a list of subarrays of x which contain consecutive integers.
on f x do extract list value by sumscan[1,!(1 drop value)=value+1] from x end
assert[f[(1, 2, 3, 6, 7, 8, 9   )] "%j"parse"[[1, 2, 3], [6, 7, 8, 9]]     "]
assert[f[(11, 12, 14, 17, 18, 19)] "%j"parse"[[11, 12], [14], [17, 18, 19]]"]
assert[f[(2, 4, 6, 8            )] "%j"parse"[[2], [4], [6], [8]]          "]
assert[f[(1, 2, 3, 4, 5         )] "%j"parse"[[1, 2, 3, 4, 5]]             "]

problem[130.1]
# find the single number which appears an odd number of times in x.
# (this is a classic evil interview question but trivial if you know the trick)
assert[bits.xor[(2, 5, 4, 4, 5, 5, 2      )] 5]
assert[bits.xor[(1, 2, 3, 4, 3, 2, 1, 4, 4)] 4]

problem[127.1]
#are two sets are disjoint?
on f x y do !count x take y end
assert[f[(1, 2, 5, 3, 4) (4, 6, 7, 8, 9)] 0]
assert[f[(1, 3, 5, 7, 9) (0, 2, 4, 6, 8)] 1]

problem[126.2]
# compute minesweeper neighbor-counts for mines (x) in a text representation.
on f x do
  m:"x"=each r in "\n"split" "drop -1 drop 1 drop x ""split r end
  i:image[(count first m),count m]
  each row y in m each v x in row i[x,y]:v end end
  n:i.copy[].merge["+" i.copy[].translate[-1,0]].merge["+" i.copy[].translate[1,0]]
  i:n.copy[].merge["+" n.copy[].translate[0,-1]].merge["+" n.copy[].translate[0,1]]
  "\n%s\n"format"\n"fuse each row y in m
    " "fuse each v x in row if v "x" else i[x,y] end end
  end
end
assert[f["
x * * * x * x x x x
* * * * * * * * * x
* * * * x * x * x *
* * * x x * * * * *
x * * * x * * * * x
"] "
x 1 0 1 x 2 x x x x
1 1 0 2 2 4 3 5 5 x
0 0 1 3 x 3 x 2 x 2
1 1 1 x x 4 1 2 2 2
x 1 1 3 x 2 0 0 1 x
"]

problem[121.1]
# invert bit y of byte x.
on f x y do bits.xor[x 2^y-1] end
assert[f[12 3]  8]
assert[f[18 4] 26]

problem[120.1]
# swap the even and odd bits of a byte.
on f x do
 bits.or[
  bits.and[x 170]/2
  bits.and[x  85]*2
 ]
end
assert[f[101] 154]
assert[f[ 18]  33]

problem[120.2]
# find the (smaller) angle between the hands of an analog clock at a HH:MM time.
on f x do
 t:"%[h]i:%[m]i"parse x
 ha:(30*t.m/60)+360*t.h/12
 ma:            360*t.m/60
 min 360%(ma-ha),(ha-ma)
end
assert[f["03:10"]  35]
assert[f["04:00"] 120]
assert[f["10:10"] 115]

problem[119.1]
# swap the high and low nybbles of a byte.
on f x do
 bits.or[
  bits.and[x 240]/16
  bits.and[x  15]*16
 ]
end
assert[f[101] 86]
assert[f[ 18] 33]

problem[117.1]
# find the missing row.
# (this is like the xor trick except with more annoying io requirements.)
on f x do
 t:readcsv["n,t\n",x "is"]
 (sum 1+range 1+count t)-sum t.n
end
assert[f[
"11, Line Eleven
1, Line one
9, Line Nine
13, Line Thirteen
2, Line two
6, Line Six
8, Line Eight
10, Line Ten
7, Line Seven
4, Line Four
14, Line Fourteen
3, Line three
15, Line Fifteen
5, Line Five"
] 12]

problem[110.1]
# filter a file to only "valid" phone numbers of a few specific formats.
on f x do
  "\n"fuse extract where value like ("+## ##########","(##) ##########","#### ##########") from "\n"split x
end
assert[f[
"0044 1148820341
+44 1148820341
44-11-4882-0341
(44) 1148820341
00 1148820341"
]
"0044 1148820341
+44 1148820341
(44) 1148820341"
]

problem[110.2]
# transpose a csv file.
on f x do "\n"fuse range each v k in cols readcsv[x] ","fuse k,v end end
assert[f[
"name,age,sex
Mohammad,45,m
Joe,20,m
Julie,35,f
Cristina,10,f"
]
"name,Mohammad,Joe,Julie,Cristina
age,45,20,35,10
sex,m,m,f,f"
]

problem[106.1]
# find the maximum difference between two successive elements once the array is sorted.
on f x do 0+max (1 drop x:extract orderby value asc from x)-x end
assert[f[(2, 9, 3, 5   )] 4]
assert[f[(1, 3, 8, 2, 0)] 5]
assert[f[(list 5       )] 0]

problem[95.2]
# implement a stack Object.
on stack_new do
 local s:()
 r.push:on push x do s:s,x x end
 r.pop :on pop    do t:last s s:-1 drop s t end 
 r.top :on top    do last s end
 r.minv:on minv   do min s end
end
s:stack_new[]
s.push[2],s.push[-1],s.push[0]
assert[
  (s.pop[],s.top[],s.push[0],s.minv[])
  (0      ,-1     ,0        ,-1      )
]

problem[94.1]
# group a word list into clusters of anagrams.
on f x do extract list value by sortstr@value from x end
assert[f[("opt", "bat", "saw", "tab", "pot", "top", "was")] "%j"parse"[['opt','pot','top'],['bat','tab'],['saw','was']]"]

problem[92.1]
# are two words isomorphic?
on sig x do extract group by value from x end
on f x y do sig[x]~sig[y] end
assert[f["abc" "xyz"] 1]
assert[f["abb" "xyy"] 1]
assert[f["sum" "add"] 0]

problem[91.1]
# see-and-say numbers.
on f x do
 0+"" fuse extract (count value),first value by sumscan[1,!(1 drop value)=value] from ""split x
end
assert[f[1122234] 21321314  ]
assert[f[2333445] 12332415  ]
assert[f[12345  ] 1112131415]

problem[90.1]
# show the complementary DNA strand nucleotide sequence.
on f x do ""fuse("TAGC"dict"ATCG")@x end
assert[
  f["GTAAACCCCTTTTCATTTAGACAGATCGACTCCTTATCCATTCTCAGAGATGTGTTGCTGGTCGCCG"]
    "CATTTGGGGAAAAGTAAATCTGTCTAGCTGAGGAATAGGTAAGAGTCTCTACACAACGACCAGCGGC"
]

problem[88.1]
# return an array where r[i] is the product of all elements of x except x[i].
on f x do each v in x prod(list v)drop x end end
assert[f[(5, 2, 1, 4, 3)] (24, 60, 120, 30, 40)]
assert[f[(2, 1, 4, 3   )] (12, 24, 6, 8       )]

problem[87.1]
# find the longest consecutive sequence in x, or return 0 if no sequence is longest.
on f x do
 r:extract orderby count value asc from
  extract list value by sumscan[1,!(1 drop value)=value+1] orderby value asc from x
 if (count r[0])>count r[1] r[0] else 0 end
end
assert[f[(100, 4, 50, 3, 2  )] (2, 3, 4  )]
assert[f[(20, 19, 9, 11, 10 )] (9, 10, 11)]
assert[f[(20, 30, 10, 40, 50)] 0          ]

problem[83.1]
# count characters in a sentence minus the first and last word, ignoring whitespace.
on f x do count""fuse -1 drop 1 drop" "split x end
assert[f["The Weekly Challenge"                   ] 6]
assert[f["The purpose of our lives is to be happy"] 23]

problem[79.2]
# how much water can be trapped between the columns of a histogram?
on f x do
 sum mag @ x - rev[maxscan[rev[x]]] & maxscan[x]
end
assert[f[(2, 1, 4, 1, 2, 5)] 6]
assert[f[(3, 1, 3, 1, 1, 5)] 6]

problem[78.1]
# identify elements which are greater than all the elements to their right.
on f x do extract where value=rev[maxscan[rev[x]]] from x end
assert[f[(9, 10, 7, 5, 6, 1)] (10, 7, 6, 1)]
assert[f[(3, 4, 5          )] (list 5     )]

problem[73.1]
# find the minimum of each y-length sliding window of x.
on f x y do min@(-y)window x end
assert[f[(1, 5, 0, 2, 9, 3, 7, 6, 4, 8) 3] (0, 0, 0, 2, 3, 3, 4, 4)]

problem[71.1]
# find elements which are greater than their neighbors.
# (problem says the script should generate a random array, but that's silly.)
on f x do extract where value>(1 drop value,0)|(-1 drop 0,x) from x end
assert[f[(18, 45, 38, 25, 10, 7, 21, 6, 28, 48)] (45, 21, 48    )]
assert[f[(47, 11, 32, 8, 1, 9, 39, 14, 36, 23 )] (47, 32, 39, 36)]

problem[62.1]
# sort and deduplicate email addresses by domain (case-insensitive), then mailbox (case-sensitive).
# (simplified IO relative to the problem statement.)
on f x do
 extract first addr by box join domain orderby domain join box asc from
  update addr:x from table "%[box]s@%[domain]l" parse x
end
assert[
  f[("name@example.org","rjt@cpan.org","Name@example.org","rjt@CPAN.org","user@alpha.example.org")]
  ("user@alpha.example.org","rjt@cpan.org","Name@example.org","name@example.org")
]

problem[54.2]
# calculate terms of the collatz sequence starting from x.
on f x do
 r:list x
 while !1~x
  r:r,x:if 2%x 1+3*x else x/2 end
 end
end
assert[f[23] (23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1)]

problem[50.1]
# given a list of intervals [a,b], merge any overlapping intervals.
on isect x y do if ((x[1])<(y[0])) x else x[0],y[1] end end
on f x do
  r:() a:first x
  each v in 1 drop x
    t:isect[a v]
    a:if t~a r:r,list t v else t end
  end
  r,list a
end
assert[
  f["%j" parse "[[2,7], [3,9], [10,12], [15,19], [18,22]]"]
  "%j" parse "[[2, 9], [10, 12], [15, 22]]"
]

problem[46.1]
# given a set of strings, extract the most common character for each position.
on mode x do
  first extract orderby c desc from
    select v:first value c:count value by value from x
end
on f x do "" fuse mode @ flip each v in "\n" split x " " drop v end end
assert[f[
1 drop "
H x l 4 !
c e - l o
z e 6 l g
H W l v R
q 9 m # o"
]
"Hello"
]
assert[f[
1 drop "
P + 2 l ! a t o
1 e 8 0 R $ 4 u
5 - r ] + a > /
P x w l b 3 k \\
2 e 3 5 R 8 y u
< ! r ^ ( ) k 0"
]
"PerlRaku"
]

problem[42.1]
# produce the (decimal) numbers 1-50 in octal.
on f do
  v:1+range 50
  (10*floor v/8)+8%v
end
assert[f[] (1,2,3,4,5,6,7,10,11,12,13,14,15,16,17,20,21,22,23,24,25,26,27,30,31,32,33,34,35,36,37,40,41,42,43,44,45,46,47,50,51,52,53,54,55,56,57,60,61,62)]

problem[42.2]
# are parentheses in a string balanced?
# (problem says generate random strings, but, again, that's silly.)
on f x do !max 0>sumscan[("()"dict 1,-1)@x] end
assert[f["()"   ] 1]
assert[f["(())" ] 1]
assert[f[")("   ] 0]
assert[f["())()"] 0]

problem[40.2]
# sort the items of x at indices y.
on f x y do
  last each v i in extract orderby value asc from x@y
    x[y[i]]:v
  end
end
assert[f[(10, 4, 1, 8, 12, 3) (0,2,5)] (1, 4, 3, 8, 12, 10)]

problem[32.1]
# perform a frequency count of lines in a file and produce a csv summary.
on f x do
  ("\n","%s,%i")format select first value count value by value from "\n"split x
end
assert[f["apple\nbanana\napple\ncherry\ncherry\napple"] "apple,3\nbanana,1\ncherry,2"]

problem[20.1]
# split a string into runs of the same character.
on f x do
  extract "" fuse value by sumscan[1,!(1 drop value)=value] from x
end
assert[f["ABBCDEEF"] "%j"parse"['A','BB','C','D','EE','F']"]
assert[f["AAAABBAA"] "%j"parse"['AAAA','BB','AA'         ]"]

# conclusion:

print["all integration tests passed."]
